{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 本“书”记录我的算法分析学习历程 "},"Chapter1/Chapter1.html":{"url":"Chapter1/Chapter1.html","title":"分治法","keywords":"","body":"第一篇 分治法 "},"Chapter1/中位数.html":{"url":"Chapter1/中位数.html","title":"中位数","keywords":"","body":"Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)).中位数的概念 将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。 方法： 分治法 算法分析 将有序数组分成两部分，可以得到如下关系式:len(left_part)=len(right_part) max(left_part)≤min(right_part) left_part right_part A[0], A[1], ..., A[i-1] A[i], A[i+1], ..., A[m-1] B[0], B[1], ..., B[j-1] B[j], B[j+1], ..., B[n-1] 那么，中位数就是：median=[max(leftpart)+min(rightpart)]/2median=[max(left_part)+min(right_part)] / 2 median=[max(left​p​​art)+min(right​p​​art)]/2 代码如下： int findMedianSortedArrays(int A[],int A_len, int B[],int B_len) { int m=A_len,n=B_len; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin A[i]){ iMin = i + 1; // i is too small,需要增大i，减小j } else if (i > iMin && A[i-1] > B[j]) { iMax = i - 1; // i is too big,需要减小i，增大j } else { // i is perfect，i是临界值，0或者m int maxLeft = 0; if (i == 0) { maxLeft = B[j-1]; } else if (j == 0) { maxLeft = A[i-1]; } else { maxLeft = max(A[i-1], B[j-1]); } if ( (m + n) % 2 == 1 ) { return maxLeft; } int minRight = 0; if (i == m) { minRight = B[j]; } else if (j == n) { minRight = A[i]; } else { minRight = min(B[j], A[i]); } return (maxLeft + minRight) / 2; } } } 运行结果:　　数组元素为:array1[3] = {1,2,7}; array2[3] = {3,5,6};　　 算法复杂度分析: 时间复杂度：查找的区间是[0,m],每次循环之后，查找区间的长度都会降为原先的一半。所以，最多执行lg(m)lg(m)lg(m)次。 由于m=n mm=n,所以时间复杂度为O(lg(min(m,n))) O(lg(min(m,n))) O(lg(min(m,n)))。 "},"Chapter1/最大子序和.html":{"url":"Chapter1/最大子序和.html","title":"最大子序和","keywords":"","body":"最大子序和 给定一个整数数组nums，找到一个具有最大和的连续子数组(子数组最少包含一个元素)，返回其最大和。 示例 :输入: [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大为6 方法： 分治法 算法分析： 把数组分成左右两个子数组，最大自序和只可能出现在　1.左子数组　2.右子数组　3.横跨左右子数组的部分或全部元素 然后对左子数组或右子数组时，进一步拆分，依次循环，直至拆分的子数组中只有一个元素。 拆分序列（直到只剩下一个数的数组） 求左子数组最大值 求右子数组最大值 求横跨左右子数组的最大值 合并，得出以上三个最大值的最大值 当最大子数组有 nnn 个数字时： 若 n==1n==1n==1，返回此元素。 left_sum 是左子数组的元素之和最大值 right_sum 是右子数组的元素之和最大值 cross_sum 是横跨左右子数组元素之和的最大值 代码如下: #include using std::cout; using std::cin; using std::endl; int CrossSum(int nums[],int left, int right, int mid) { if (left == right) return nums[left]; int leftSubSum=0; int leftMaxSum=nums[mid];//横跨左右子数组，则基准元素(左边第一个元素)必然包含在内 for(int i=mid; i>=left; i--) { leftSubSum+=nums[i]; leftMaxSum=leftMaxSum>=leftSubSum?leftMaxSum:leftSubSum; } int rightSubSum=0; int rightMaxSum=nums[mid+1];//横跨左右子数组，则右边第一个元素必然包含在内 for(int i=mid+1; i=rightSubSum?rightMaxSum:rightSubSum; } return leftMaxSum+rightMaxSum; } int fun(int nums[],int left, int right) { if (left == right) return nums[left]; int mid = (left + right) / 2; int leftSum = fun(nums, left, mid); int rightSum = fun(nums, mid + 1, right); int crossSum = CrossSum(nums, left, right, mid); int temp=leftSum>rightSum?leftSum:rightSum; return temp>crossSum?temp:crossSum; } int MaxSubArray(int nums[],int length) { return fun(nums,0,length-1); } int main() { int nums[9]={-2,1,-3,4,-1,2,1,-5,4}; int maxSum=MaxSubArray(nums,9); cout 运行结果： maxSum= 6 算法复杂度分析: 递归树法：时间复杂度：O(nlg(n))O(nlg(n))O(nlg(n)) "}}